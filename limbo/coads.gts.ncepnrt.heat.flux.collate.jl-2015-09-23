#=
 = Collate in situ observations in time and space using the
 = resolution of reference gridded analyses (i.e., daily at
 = 0.25 degrees) - RD September 2015
 =#

using My
const POSS             = 5516                           # number of locations with available timeseries
const DAYS             = 3745                           # number of days between 1999-10-01 and 2009-12-31
const MISS             = -9999.0                        # generic missing value

if size(ARGS) == (0,)
  write("\nUsage: jj $(basename(@__FILE__)) all.flux insitu\n\n")
  exit(1)
end

lats =  [-90.0:0.25:89.75]                                                    # define the grid and initialize
lons = [-180.0:0.25:179.75]                                                   # the collocations
shfx = Array(Float64, POSS, DAYS)
lhfx = Array(Float64, POSS, DAYS)
dirs = ["cfsr", "erainterim", "hoaps", "ifremerflux", "j-ofuro", "merra", "oaflux", "seaflux"]

numb = zeros(length(lons), length(lats))

write("reading $(ARGS[1])\n")
csv = readcsv(ARGS[1])                                                        # find the set of collocations
vals, = size(csv)


for a = 1:vals
  lat = csv[a,5]
  lon = csv[a,6] ; lon < -180 && (lon += 360)
  dellat, indlat = findmin(abs(tats - lat))
  dellon, indlon = findmin(abs(tons - lon))
  if topo[indlon,indlat,1] < 0 && 199909999999 < float(csv[a,4]) < 201000000000
    dellat, indlat = findmin(abs(lats - lat))
    dellon, indlon = findmin(abs(lons - lon))
    push!(subs, (lats[indlat], lons[indlon]))
    numb[indlon,indlat] += 1
  end
end

for (a, lat) in enumerate(lats)
  for (b, lon) in enumerate(lons)
    if numb[b,a] > 0
      tmp = @sprintf("%9.3f.%9.3f", lat, lon)
      tmq = replace(tmp, " ", ".")
      tmr = "$(ARGS[2])/$(ARGS[2]).$tmq"
      fpa = My.ouvre(tmr, "w")
      for loc in subs
        (lat, lon) = loc
        indlat = findfirst(lats, lat)
        indlon = findfirst(lons, lon)
        line = @sprintf("%8.2f, %8.2f, %8f\n", lat, lon, numb[indlon,indlat])
        write(fpa, line)
      end
      close(fpa)
    end
  end
end
exit(0)



#=
ARGS[1] = "all.flux.locate.sort"
csv = readcsv(ARGS[1]) ; (vals,) = size(csv)                                  # true wherever buoys are located
for a = 1:vals  push!(buoy, (csv[a,2], csv[a,1]))  end                        # and initialize filename components

lats =  -90.0:0.25:89.75                                                      # locs[   1,  1] = (-180.00,-90.00)
lons = -180.0:0.25:179.75                                                     # locs[   1,720] = (-180.00, 89.75)
locs = [   (x, y)        for x=lons, y=lats]                                  # locs[1440,  1] = ( 179.75,-90.00)
mask = [in((x, y), buoy) for x=lons, y=lats]                                  # locs[1440,720] = ( 179.75, 89.75)
varc = locs[mask .== true] ; (varn,) = size(varc)

fpn = Array(IOStream, 0)                                                      # then open a set of output files
for a = 1:varn
  (lon, lat) = varc[a]
  tmp = @sprintf("%9.3f.%9.3f", lat, lon)
  tmq = replace(tmp, " ", ".")
# tmr = "$(ARGS[2])/$(ARGS[1]).$tmq"
  tmr = "$(ARGS[2])/$(ARGS[2]).$tmq"
  fpa = My.ouvre(tmr, "w")
  push!(fpn, fpa)
end

date = "19991001120000"
while int(date) < 20100101000000
  file = ARGS[2] * "/" * stem * date * tail ; println(file)
  if isfile(file)
    shflag = lhflag = true
  else
    for a = 1:varn
      tmp = @sprintf("%s %9.3f %9.3f\n", date[1:10], MISS, MISS)
      write(fpn[a], tmp)
    end
  end
  date = My.dateadd(date, 1, "dy")
end

@printf("%f,%f became %f,%f\n", lat, lon, tats[indlat], tons[indlon])
@printf("%f,%f became %f,%f\n", lat, lon, lats[indlat], lons[indlon])
=#
